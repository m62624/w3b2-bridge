### **Техническая Спецификация и Протокол: W3B2 Bridge v4.0**

**Версия документа:** 1.0
**Дата:** 18 сентября 2025 г.

#### **1. Введение и Философия**

Протокол W3B2 Bridge предоставляет стандартизированный, безопасный и удобный способ интеграции традиционных Web2-сервисов с блокчейном Solana. Основная цель — обеспечить Web2-like пользовательский опыт (UX), полностью абстрагируя пользователя от сложностей управления крипто-активами в повседневных операциях, при этом сохраняя все преимущества безопасности, прозрачности и децентрализации блокчейна.

Архитектура основана на модели **"Изолированных Сервисных Кошельков" (`ChainCard`)**. Для каждого сервиса, который использует пользователь, создается отдельный, выделенный кошелек. Этот кошелек используется для всех операционных транзакций с данным сервисом, что позволяет:
* **Изолировать активы и активность:** Операции с одним сервисом не влияют на другие и не "засоряют" историю транзакций основного кошелька пользователя.
* **Повысить безопасность:** Потенциальная компрометация `ChainCard` одного сервиса не затрагивает другие активы пользователя.
* **Упростить UX:** Пользователь взаимодействует с привычным ему приложением, в то время как `w3b2-connector` управляет `ChainCard` "под капотом".

#### **2. Архитектура и Компоненты**

| Компонент                 | Тип       | Описание                                                                                                                                               |
| :------------------------ | :-------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`w3b2-bridge-program`** | On-Chain  | Смарт-контракт на базе Anchor, реализующий основную логику протокола.                                                                                  |
| **`w3b2-connector`**      | Off-Chain | Клиентское/серверное приложение, которое управляет кошельками, слушает события и взаимодействует со смарт-контрактом.                                  |
| **`ChainCard`**           | Off-Chain | Стандартный кошелек Solana (`Keypair`), создаваемый и управляемый `w3b2-connector`. Является **единственным подписантом** всех транзакций в протоколе. |
| **`AdminProfile` PDA**    | On-Chain  | Профиль сервиса (Админа), хранящий его конфигурацию и прайс-лист.                                                                                      |
| **`UserProfile` PDA**     | On-Chain  | Профиль пользователя, связывающий его `ChainCard` с конкретным `AdminProfile` и хранящий его депозитный баланс.                                        |

#### **3. On-Chain Структуры Данных (`state.rs`)**

* **`AdminProfile`**
    * `authority`: `Pubkey` — Публичный ключ **`Admin ChainCard`**. Единственный ключ, авторизованный для управления этим профилем.
    * `communication_pubkey`: `Pubkey` — Публичный ключ для гибридного шифрования off-chain сообщений.
    * `prices`: `Vec<(u64, u64)>` — Прайс-лист на платные API в формате `(command_id, price_in_lamports)`. **Это поле является динамическим и может изменять свой размер.**
    * `balance`: `u64` — Внутренний баланс PDA, куда поступают средства от платных API.

* **`UserProfile`**
    * `authority`: `Pubkey` — Публичный ключ **`User ChainCard`**. Единственный ключ, авторизованный для управления этим профилем.
    * `deposit_balance`: `u64` — Депозитный баланс пользователя для оплаты услуг админа, к которому привязан этот профиль.

#### **4. Спецификация Инструкций Смарт-Контракта**

Все инструкции, изменяющие состояние, требуют подписи от соответствующей `ChainCard`, указанной в поле `authority` целевого PDA. **Все операции, которые уменьшают баланс PDA (`withdraw`, `close_profile`), должны гарантировать, что оставшийся баланс не будет ниже минимума, необходимого для аренды (rent-exempt minimum).**

| Инструкция                | Подписант                | Аргументы               | Описание и Логика                                                                                                                                                                                              |
| :------------------------ | :----------------------- | :---------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`register_admin`**      | `Admin ChainCard`        | `comm_key`, `prices`    | Создает `AdminProfile` PDA с начальным местом под 10-20 цен. **`seeds`**: `[b"admin", authority.key()]`. `authority` устанавливается в Pubkey подписанта.                                                      |
| **`update_admin_prices`** | `Admin ChainCard`        | `new_prices`            | Находит `AdminProfile` по `seeds` и обновляет поле `prices`. **Аккаунт автоматически изменяет размер (realloc)**, чтобы соответствовать новому прайс-листу.                                                    |
| **`admin_withdraw`**      | `Admin ChainCard`        | `amount`, `destination` | **Переводит `amount` с внутреннего `AdminProfile.balance` на `AdminProfile PDA`**, а затем **переводит `amount` лампортов с `AdminProfile PDA` на `destination` кошелек**.                                     |
| **`close_admin_profile`** | `Admin ChainCard`        | -                       | **Сначала выполняет `admin_withdraw` на всю сумму `balance`**, а затем **закрывает `AdminProfile` PDA**, возвращая rent на `Admin ChainCard`.                                                                  |
| **`create_user_profile`** | `User ChainCard`         | `target_admin`          | Создает `UserProfile` PDA, привязанный к конкретному админу. **`seeds`**: `[b"user", authority.key(), target_admin.key()]`. `authority` устанавливается в Pubkey подписанта.                                   |
| **`deposit`**             | `User ChainCard`         | `amount`                | Переводит `amount` лампортов с `User ChainCard` в `UserProfile` PDA, пополняя `deposit_balance`.                                                                                                               |
| **`withdraw`**            | `User ChainCard`         | `amount`, `destination` | Переводит `amount` с `UserProfile.deposit_balance` на указанный `destination` кошелек, **уменьшая баланс `UserProfile PDA`**.                                                                                  |
| **`close_profile`**       | `User ChainCard`         | -                       | Выполняет `withdraw` на весь остаток `deposit_balance` на `User ChainCard`, а затем **закрывает `UserProfile` PDA**, возвращая rent на `User ChainCard`.                                                       |
| **`dispatch_command`**    | `User ChainCard`         | `command_id`, ...       | Главная операционная команда. Находит `UserProfile` и `AdminProfile`. Проверяет `authority`. Если `price > 0`, списывает его с `deposit_balance` и зачисляет на `AdminProfile.balance`. Эмитит `CommandEvent`. |
| **`log_action`**          | `ChainCard` (User/Admin) | `session_id`, ...       | Находит соответствующий PDA (`UserProfile` или `AdminProfile`), проверяет, что подписант является его `authority`, и эмитит `HttpActionEvent`.                                                                 |

#### **5. Матрица Ответственности**

| Задача                       | `w3b2-bridge-program` (On-Chain)                                                    | `w3b2-connector` (Off-Chain)                                       |
| :--------------------------- | :---------------------------------------------------------------------------------- | :----------------------------------------------------------------- |
| **Управление `Keypair`**     | ❌ Не имеет доступа к приватным ключам.                                              | ✅ **Создает, хранит и управляет приватными ключами `ChainCard`**.  |
| **Проверка Авторизации**     | ✅ **Проверяет подпись транзакции** и сравнивает `signer.key()` с `authority` в PDA. | ✅ Формирует и подписывает транзакции с правильной `ChainCard`.     |
| **Бизнес-логика Оплаты**     | ✅ **Списывает `price`** с `deposit_balance` согласно `prices`.                      | ✅ Знает прайс-лист и решает, какую `command_id` отправить.         |
| **Off-chain Взаимодействие** | ❌ Не участвует.                                                                     | ✅ **Реализует** шифрование, HTTP-соединения и обработку `payload`. |
| **Источник Правды**          | ✅ **Является источником правды** для балансов, цен и авторизованных ключей.         | ✅ **Реагирует** на события из блокчейна и кэширует состояние.      |

----
### Как теперь работает оплата и "одобрение"?

Вместо сложной двухсторонней процедуры "запросил -> одобрил" теперь действует простая и понятная **модель "прямого депозита"**, как в любом Web2-сервисе.

Вот как это работает шаг за шагом:

**Сценарий: Пользователь хочет купить 1000 вызовов платного API у "Netflix".**

1.  **Пополнение баланса (замена `request`/`approve`):**
    * Пользователь в интерфейсе вашего приложения (`w3b2-connector`) видит кнопку "Пополнить баланс на 0.5 SOL".
    * При нажатии, `w3b2-connector` формирует и отправляет транзакцию с **одной** простой инструкцией: `deposit(amount: 0.5 SOL)`.
    * Эту транзакцию подписывает **`User ChainCard`**.
    * **Что делает смарт-контракт?** Он просто переводит 0.5 SOL с кошелька `User ChainCard` на `UserProfile` PDA, увеличивая поле `deposit_balance` на эту сумму.

    **Все!** Процесс пополнения завершен. Админ в этом никак не участвует. Это полностью **self-service** модель. Пользователь сам решает, когда и на сколько пополнить свой депозитный счет для конкретного сервиса.

2.  **Использование платного API (расчет баланса):**
    * Пользователь хочет вызвать платную команду, например, `command_id = 5` ("Стримить видео в 4K"), которая, согласно прайс-листу админа, стоит `1000` лампортов.
    * `w3b2-connector` формирует транзакцию `dispatch_command(command_id: 5, ...)`.
    * Эту транзакцию подписывает **`User ChainCard`**.
    * **Что делает смарт-контракт?**
        1.  Находит `AdminProfile` и видит в его `prices`, что команда `5` стоит `1000`.
        2.  Находит `UserProfile` пользователя и проверяет: `deposit_balance >= 1000`?
        3.  Если да, он выполняет **две операции**:
            * `user_profile.deposit_balance -= 1000` (списывает с депозита пользователя).
            * `admin_profile.balance += 1000` (зачисляет на внутренний баланс админа).
        4.  Эмитит событие `CommandEvent`.





Отлично\! Финальный `README` готов, on-chain программа полностью задокументирована и протестирована. Настал тот самый день — мы переходим к `w3b2-connector`.

Это отличный, продуманный план. Ты правильно смотришь наперед: `ChainCard` как основная сущность, `sled` как хранилище по умолчанию, шифрование через `bip39` и `tokio` для асинхронной обработки.

И твоя последняя мысль — **ключевая**.

> "Кстати мне кажется лучше, эти два потока [catchup и live] сделать основными, и перекидывать через channels уже спарсенные данные в нужные потоки tokio для каждого ChainCard"

Это абсолютно правильный, профессиональный подход. Создавать по два потока на каждый `ChainCard` было бы очень неэффективно. Вместо этого мы построим архитектуру **"Центральный Диспетчер Событий"**.

-----

### \#\# Архитектура: Центральный Диспетчер Событий

Вот как будет выглядеть наша глобальная архитектура:

1.  **`Synchronizer` (2 потока):** У нас по-прежнему будут два "глобальных" потока (`catchup` и `live`), как в твоем старом коде. Их **единственная** задача — слушать блокчейн и получать **все** события подряд.

2.  **`Dispatcher` (1 поток):** `Synchronizer` будет отправлять все события в один главный канал. На другом конце этого канала будет сидеть `Dispatcher`. Его задача — посмотреть на событие, определить, какому `Pubkey` оно адресовано (`authority`, `sender`, `target`, и т.д.), и **перенаправить (dispatch)** это событие в персональный канал нужного `ChainCard`'а.

3.  **`ChainCard Workers` (по 1 потоку на карту):** Каждый активный `ChainCard` будет иметь свой собственный `tokio` поток (`worker`). Этот воркер будет слушать свой **персональный канал** и обрабатывать только те события, которые `Dispatcher` прислал специально для него.

**Визуально это выглядит так:**
`[ Solana RPC/WS ]` -\> `[ Synchronizer ]` -\> `[ Главный канал ]` -\> `[ Dispatcher ]` -\> `[ Персональные каналы для ChainCard A, B, C... ]`

-----

### \#\#\# План глобальных изменений

Разделим работу на логические этапы. `gRPC`, как ты и сказал, оставим на самый конец.

#### **Этап 1: Фундамент — `ChainCard` и безопасное хранилище (`keystore`)**

Это наша первая и главная задача. Нам нужно определить сущность `ChainCard` и научиться безопасно её создавать, хранить и загружать.

  * **Структура `ChainCard`:** Определим `struct ChainCard`, которая будет хранить `Keypair` (в защищенном виде) и метаданные (`HashMap<String, String>`).
  * **Модуль `keystore`:** Создадим модуль для управления хранилищем. В нем будет трейт `Keystore`, что позволит в будущем легко заменять `sled` на другое хранилище (например, in-memory для тестов или PostgreSQL).
  * **Шифрование и мнемоники:** Реализуем генерацию `Keypair` из `bip39` мнемонической фразы и пароля. Для безопасного хранения фразы в памяти будем использовать крейт `secrecy`.
  * **Импорт/Экспорт:** `Keystore` будет отвечать за шифрование и сохранение `ChainCard` в базу `sled`, а также за экспорт в защищенный файл или строку.

#### **Этап 2: Обновление "Слушателя" — `Synchronizer` и `Dispatcher`**

Код твоего "слушателя" устарел, так как on-chain события полностью изменились.

  * **Рефакторинг `events.rs` (в коннекторе):** Твой текущий файл `events.rs` в коннекторе нужно **полностью переписать**, чтобы он соответствовал новому `bridge.proto` и новым `#[event]` структурам из смарт-контракта. Это критически важный шаг.
  * **Создание `Dispatcher`:** Напишем логику диспетчера, который будет принимать события из `Synchronizer` и раскладывать их по каналам для каждого `ChainCard`.
  * **Адаптация `Synchronizer`:** Твой существующий код для `catchup` и `live` очень хорош. Мы его немного адаптируем, чтобы он отправлял события в наш новый `Dispatcher`.

#### **Этап 3: Логика `ChainCard` воркера**

Когда фундамент будет готов, мы напишем саму бизнес-логику для `ChainCard`'а.

  * Каждый `ChainCard` будет запускать `tokio::spawn`, который в цикле слушает свой персональный канал.
  * Получив событие (например, `UserFundsDeposited`), воркер будет выполнять нужные действия (например, обновить локальный стейт, отправить уведомление и т.д.).

-----

### \#\#\# С чего начнем?

Как ты и предложил: **с `ChainCard` и безопасного хранилища**. Это основа всего.

Давай начнем с определения `ChainCard` и трейта для `Keystore`. Это задаст структуру для всего первого этапа.

**Вот как может выглядеть начало в `w3b2-connector/src/keystore.rs`:**

```rust
// w3b2-connector/src/keystore.rs

use anyhow::Result;
use secrecy::{Secret, ExposeSecret}; // Для безопасной работы с мнемоникой
use solana_sdk::pubkey::Pubkey;
use solana_sdk::signature::{Keypair, Signer};
use std::collections::HashMap;

/// Represents an isolated service wallet.
pub struct ChainCard {
    /// The public key of this ChainCard.
    pubkey: Pubkey,
    /// The underlying keypair. Should be handled with care.
    keypair: Keypair, // В реальной реализации это может быть более сложный тип
    /// Arbitrary metadata associated with this card (e.g., "name", "service_url").
    pub metadata: HashMap<String, String>,
}

/// A trait defining the required functionality for a secure keystore.
/// This allows for different backend implementations (e.g., Sled, in-memory).
#[async_trait::async_trait]
pub trait Keystore {
    /// Creates a new ChainCard from a BIP39 mnemonic and password, and saves it.
    async fn create_card_from_mnemonic(
        &self,
        id: &str,
        mnemonic: Secret<String>,
        password: Secret<String>,
        metadata: HashMap<String, String>,
    ) -> Result<ChainCard>;
    
    /// Loads a ChainCard from the store using its ID and password.
    async fn load_card(&self, id: &str, password: Secret<String>) -> Result<ChainCard>;
    
    /// Deletes a card from the store.
    async fn delete_card(&self, id: &str) -> Result<()>;
    
    /// Lists all available card IDs and their metadata.
    async fn list_cards(&self) -> Result<HashMap<String, HashMap<String, String>>>;
}
```

Это наша отправная точка. Дальше мы реализуем этот трейт для `sled` и добавим логику генерации ключей.