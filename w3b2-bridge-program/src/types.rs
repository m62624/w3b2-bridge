use super::*;

#[derive(Debug)]
#[account]
pub struct AdminAccount {
    /// registrant pubkey as raw bytes ([u8;32])
    pub owner: [u8; 32],
}

/// Minimal on-chain user record stored in PDA.
/// Keep fields minimal to reduce rent.
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct UserAccount {
    /// Controller / registrant pubkey as raw bytes ([u8;32]).
    pub owner: [u8; 32],
    /// Whether created wallet or linked existing.
    pub account_type: WalletType,
}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub enum WalletType {
    /// Wallet generated by client (new keypair).
    NewWallet,
    /// Wallet the user already owns and wants to link.
    ExistingWallet,
}

/// Command mode: request-response (two-step) or one-way (fire-and-forget).
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub enum CommandMode {
    /// Bridge should wait for response from target service (response will be written back on-chain).
    RequestResponse = 0,
    /// Bridge simply executes off-chain action; no on-chain response expected.
    OneWay = 1,
}

/// Minimal on-chain command descriptor.
/// `payload` contains a small Borsh(CommandConfig) or other small blob.
/// Keep payload size bounded (recommend <= 1024 bytes).
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct CommandRecord {
    /// Sender pubkey as raw bytes (author of transaction).
    pub sender: [u8; 32],
    /// Numeric command id (protocol-level).
    pub command_id: u64,
    /// Command mode (RequestResponse / OneWay).
    pub mode: CommandMode,
    /// Encrypted or plain small blob. Normally this is Borsh(CommandConfig).
    pub payload: Vec<u8>,
}

/// Destination for off-chain service connection.
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub enum Destination {
    /// IPv4 address + port.
    IpV4([u8; 4], u16),
    /// IPv6 address + port.
    IpV6([u8; 16], u16),
    /// URL string (Borsh length-prefixed).
    Url(String),
}

/// CommandConfig â€” structure the client builds and serializes (Borsh) into CommandRecord.payload.
/// Important:
/// - `session_key` is **always 32 bytes AES-256 key**.
/// - `encrypted_session_key` is a fixed 80-byte block produced by hybrid encryption
///   (X25519 ephemeral pubkey + ciphertext + AEAD tag).
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct CommandConfig {
    /// Session identifier (nonce / u64).
    pub session_id: u64,
    /// Encrypted AES-256 session key (X25519+AEAD).
    /// Format: [ephemeral_pubkey(32) | ciphertext(32) | tag(16)] = 80 bytes.
    pub encrypted_session_key: [u8; 80],
    /// Destination (ip/port or url).
    pub destination: Destination,
    /// Optional small metadata (application-specific).
    pub meta: Vec<u8>,
}

// Space calculation:
// - Anchor discriminator: 8
// - owner: 32
// total = 8 + 32 = 40
#[derive(Debug, Accounts)]
pub struct RegisterAdmin<'info> {
    #[account(
        init,
        payer = payer,
        space = 40,
        seeds = [b"admin", authority.key().as_ref()],
        bump
    )]
    pub admin_profile: Account<'info, AdminAccount>,

    #[account(mut)]
    pub payer: Signer<'info>,
    /// The admin wallet that signs and will be registered.
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Debug, Accounts)]
pub struct FundUserWallet<'info> {
    /// The admin account PDA
    #[account(
        mut,
        seeds = [b"admin", authority.key().as_ref()],
        bump,
    )]
    pub admin_profile: Account<'info, AdminAccount>,

    /// The wallet of the user to fund
    #[account(mut)]
    pub user_wallet: SystemAccount<'info>,

    /// The admin wallet that signs the transaction to fund the user
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Debug)]
#[account]
pub struct UserPda {
    /// Common user profile (owner + account_type) from w3b2_common.
    pub profile: UserAccount,
    /// Optional linked wallet (raw bytes).
    pub linked_wallet: Option<[u8; 32]>,
    /// Unix timestamp when created.
    pub created_at: u64,
}

// Space calculation:
// - Anchor discriminator: 8
// - profile.owner: 32
// - profile.account_type: 1
// - linked_wallet: 1 + 32 = 33 (option tag + bytes)
// - created_at: 8
// total = 8 + 32 + 1 + 33 + 8 = 82
// add margin/padding -> 96
#[derive(Debug, Accounts)]
pub struct RegisterUser<'info> {
    #[account(
        init_if_needed,
        payer = payer,
        space = 96,
        seeds = [b"user", authority.key().as_ref()],
        bump
    )]
    pub user_pda: Account<'info, UserPda>,

    #[account(mut)]
    pub payer: Signer<'info>,
    /// Wallet that signs and will be registered (controller)
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Debug, Accounts)]
pub struct DispatchCommand<'info> {
    #[account(mut, seeds = [b"user", authority.key().as_ref()], bump)]
    pub user_pda: Account<'info, UserPda>,
    /// signer issuing the command
    pub authority: Signer<'info>,
}

/* ---------- Events ---------- */

/// Use raw bytes for on-chain events to avoid borsh-version headaches across crates.
/// Off-chain listeners convert bytes -> Pubkey if they want.
#[derive(Debug)]
#[event]
pub struct UserRegistered {
    /// registrant pubkey as raw bytes ([u8;32])
    pub owner: [u8; 32],
    pub account_type: WalletType,
    pub linked_wallet: Option<[u8; 32]>,
    pub ts: i64,
}

#[derive(Debug)]
#[event]
pub struct CommandEvent {
    /// sender pubkey as raw bytes ([u8;32])
    pub sender: [u8; 32],
    pub command_id: u64,
    pub mode: CommandMode,
    pub payload: Vec<u8>,
    pub ts: i64,
}

/* ---------- Errors ---------- */
