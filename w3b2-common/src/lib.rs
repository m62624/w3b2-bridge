use anchor_lang::prelude::*;

pub mod command;

/// Account type: program-created wallet or user-provided wallet.
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub enum AccountType {
    /// Wallet generated by client (new keypair).
    NewWallet,
    /// Wallet the user already owns and wants to link.
    ExistingWallet,
}

/// Minimal on-chain user record stored in PDA.
/// Keep fields minimal to reduce rent.
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct UserAccount {
    /// Controller / registrant pubkey as raw bytes ([u8;32]).
    pub owner: [u8; 32],
    /// Whether created wallet or linked existing.
    pub account_type: AccountType,
}

/// Command mode: request-response (two-step) or one-way (fire-and-forget).
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub enum CommandMode {
    /// Bridge should wait for response from target service (response will be written back on-chain).
    RequestResponse = 0,
    /// Bridge simply executes off-chain action; no on-chain response expected.
    OneWay = 1,
}

/// Minimal on-chain command descriptor.
/// `payload` contains a small Borsh(CommandConfig) or other small blob.
/// Keep payload size bounded (recommend <= 1024 bytes).
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct CommandRecord {
    /// Sender pubkey as raw bytes (author of transaction).
    pub sender: [u8; 32],
    /// Numeric command id (protocol-level).
    pub command_id: u64,
    /// Command mode (RequestResponse / OneWay).
    pub mode: CommandMode,
    /// Encrypted or plain small blob. Normally this is Borsh(CommandConfig).
    pub payload: Vec<u8>,
}

/// Destination for off-chain service connection.
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub enum Destination {
    /// IPv4 address + port.
    IpV4([u8; 4], u16),
    /// IPv6 address + port.
    IpV6([u8; 16], u16),
    /// URL string (Borsh length-prefixed).
    Url(String),
}

/// CommandConfig â€” structure the client builds and serializes (Borsh) into CommandRecord.payload.
/// Important:
/// - `session_key` is **always 32 bytes AES-256 key**.
/// - `encrypted_session_key` is a fixed 80-byte block produced by hybrid encryption
///   (X25519 ephemeral pubkey + ciphertext + AEAD tag).
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct CommandConfig {
    /// Session identifier (nonce / u64).
    pub session_id: u64,
    /// Encrypted AES-256 session key (X25519+AEAD).
    /// Format: [ephemeral_pubkey(32) | ciphertext(32) | tag(16)] = 80 bytes.
    pub encrypted_session_key: [u8; 80],
    /// Destination (ip/port or url).
    pub destination: Destination,
    /// Optional small metadata (application-specific).
    pub meta: Vec<u8>,
}
